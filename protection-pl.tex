\subsection{Language Level Protection}

The C programming language has long been the language of choice for system-level
programming, including operating systems development. C is inherently an unsafe
programming language \cite{kint:osdi2012, undefined:apsys2012}. As such, much
effort has been made to develop operating systems in high-level languages with
stricter semantics \cite{singularity:sigops, house:icfp2005, unikernels:2013}.
These efforts have shown that language features like type safety, memory safety,
and strict aliasing can provide support for operating system protection.
Unfortunately, high-level languages often rely heavily on things like dynamic
allocation and garbage collection, which make them inapproriate for an embedded
operating system. Luckily, low-level languages are beginning to include many of
these features~\cite{c++14,rust}, making them available to embedded OS builders.

\paragraph{Type Safety.}
Strict types allow trusted modules to expose low-level hardware through an
interface that cannot be subverted by untrusted client-code. In turn, a well
designed type-safe interface can help guarantee constrain client-code to
particular operations on the underlying hardware. Moreover, compile-time
optimzations can make suc interfaces cost-free without sacrificing safety. As a
result, careful interface design can allow for minimum unsafe kernel code. We
argue that pricipled methods for designing such interfaces should be a goal of
future operating systems research.

\paragraph{Memory Safety.}
Memory safety bugs---dangling pointers, double-free, access to unallocated
memory, and pointer arithmetic errors---plague operating systems
written in languages with weak memory semantics.
Languages that guarantee memory safety obviate such bugs by catching them at
compile-time.
For instance, a kernel written in a memory safe language can enforce memory
isolation of drivers at compile time, without relying on hardware
support~\cite{spin:sosp}.

\paragraph{Strict Aliasing.}
Strict aliasing rules, such as unique references and read/write references,
%are used to
enforce thread safety
%in modern programming languages
by the language. We seek to
exploit these semantics
% to provide thread-safe hardware access
by modeling
hardware resources as references, allowing two or more applications to run
concurrently without
%fear of race conditions when accessing hardware
hardware race conditions.
% This means that two or more concurrently running applications may
% attempt to access the same hardware, resulting in access patterns unanticipated
% by the hardware. We seek to exploit strict aliasing semantics, such as unique
% and read/write references, by modeling hardware resources as references,
% guaranteeing thread-safe hardware access.
\textit{Unique references}
to hardware
guarantee that only a single active execution context
can access the reference,
%By modeling hardware as a unique reference, a
guaranteeing thread safety to applications holding the reference.
\textit{Read/write references} guarantee that two active contexts can read, but cannot mutate,
the same state.
% If two or more applications require read access to the same
% resource, read/write references can be used to make the same guarantee.
If multiple applications require write access to the same resource, a broker with a
unique reference to the resource can mediate access.
%to said resource.

By composing type safety, memory safety, and strict aliasing, a next-generation
operating system can expose safe interfaces to applications and device drivers
with strong protection guarantees at little performance cost.
