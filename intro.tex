\section{Introduction}

% This may be dipping a little too far back into history and waxing a little
% too poetic as a consequence
In 1882, Charles Babbage designed the first automated computer, the Difference
Engine. Fifteen years later, he evolved the design to create a general-purpose
machine, the Analytical Engine. Since the birth of computing, new
computational platforms have followed this trend, beginning as specialized
devices and evolving to general purpose platforms.
Most recently, the mobile phone evolved from a single-purpose voice
communication platform to add text communication, to run small Java applets,
and eventually to the full-fledged computing devices they are today, with
voice communication acting as simply another application on the device.

Today, we see the emergence of ``intelligent'' things at varying steps along
this progression: Smart watches with a clock application and a limited set of
applets, smart light bulbs that support single functions---on and off,
brighter and dimmer---, smarter light bulbs that pulse with the ambient music.
%
Traditionally, these embedded devices have been single-purpose
single-application devices. As a result, embedded ``operating systems''
generate monolithic program images, running a single application and
providing unfettered access to underlying hardware.

The key abstraction lacking in traditional embedded operating systems, but
essential to enable the next generation of embedded devices is protection. In
operating systems like TinyOS and Contiki, applications are linked into the
operating system at compile time and all parts of the code have access to the
same address- and name-space. FreeRTOS has a notion of \emph{tasks} which run
independently of the operating system, but this separation is not enforced;
applications have complete access to operating system memory regions and
hardware resources.

We introduce \name, a next-generation operating system for embedded systems.
Modern microcontrollers are both feature rich, with 32-bit processors and
diverse peripherals, and feature poor, with limited memory, energy-hungry
storage and communication, and restricted hardware support (MPUs instead of
MMUs, if at all).
%
It is time for the embedded operating system to evolve from single-application-centric
design---a glorified hardware abstraction layer---% glorified is too colloquial
% "a set of advanced libraries"? sells them too short... fixme
to a real operating system, % don't like "real" either; general-purpose, proper?
one that enables and encourages multiple concurrent, isolated applications,
provides both hardware abstractions and low-level hardware access, and offers
critical services for the applications of the Internet of Things.
%Today's fitness tracker can easily double as a medication reminder, if only
%there was a means to install and run another application.

% Hue: STM32F + CC2530 (zigbee radio)
% Pebble: Also an ST M3
% Jawbone: MSP430F5528
% Fitbit: STM 32L151C6 (another M3) + nRF8001

% THOUGHT:
%
% We make an indirect argument here by designing and OS for ARM Cortex-M.
% Namely that we are leaving other archiectures (pic, msp, avr) behind. There
% is precedent for this, x86 won as a general purpose archiecture, a key step
% towards moving forward in the embedded space is picking an archiecturural
% winner, committing to it, and moving forward. We are doing this implicitly,
% perhaps we should consider adding some text and making it an explicit choice
% somewhere.

While protection is not a new primitive in operating system design, it is a
new primitive for embedded operating system design. In the design of \name, we
take advantage of three protection mechanisms recently available to embedded
systems builders:

\begin{enumerate}
  \item \emph{Language level protection} including type safety, memory safety
    and thread safety support in modern systems programming languages.
  \item \emph{Software-managed memory protection} available in the newest
    low-power embedded microcontrollers allow the operating system to enforce
    privilege separation in hardware without the cost or complexity of a virtual
    memory.
  \item \emph{Physically timing protection}. Many new embedded products
    integrate multiple microcontrollers~\endnote{Nest protect has no less than
    three Cortex-M microcontrollers. An M4 for the application controller, an
  M0+ used as a peripheral coprocessor and 802.15.4 SoC with an onboard M3}.
  Operating systems should take advantage of this to guard time-sensitive
  components from others that might compromise timing guarantees (e.g.
  computation heavy tasks).
\end{enumerate}

We are exploring these protection mechanisms in a new embedded operating system
called \name. We are designing \name specifically for embedded products that
will allow end-users to install third-party applications during deployment and
that incorporate arbitrary new devices in many configurations.

\subsection{Language Level Protection}

\name is written in Rust: a type-safe, thread-safe, compiled, low-level systems
language. Using a language with strong safety protections has enabled \name to
formalize the separation between core kernel code and contributed device
drivers, which are traditionally where most bugs are found but are included in
the kernel for performance and practical reasons. While recent server operating
systems utilize hardware I/O virtualization~\cite{arrakis:osdi2014, ix:osdi2014}
to run device drivers outside the kernel, such hardware mechanisms are unlikely
to be available in microcontrollers in the foreseable future.

\subsection{Memory Protection}

Modern ARM Cortex-M processors provide a hardware protection mechanism called
Memory Protection Unit (MPU).  An MPU allows the kernel to set access
permissions on a fixed number of memory regions which are enforced on
application code. Unlike the Memory Manage Units (MMUs) in application
processors, MPUs do not provide virtual addressing, however, like MMUs illegal
accesses to memory regions (e.g. writing to read-only memory) are caught and
result in a fault to the kernel. Tock uses the MPU to protect kernel and driver
memory from untrusted application code and different applications from one
another, while providing applications direct access to hardware registers, such
as the GPIO.

\subsection{Multiple Processors}

Modern embedded platforms often involve multiple microprocessors in practice.
For example, both the CC2540 and the NRF51822 Bluetooth modules are, in fact,
full blown microprocessors, but many products include them in addition to
another microprocessor~\endnote{Well, at least Coin does that}. Tock leverage
multiprocessor environments to enforce another layer of isolation between
applications and the kernel, by running different application components on
different cores depending on their needs to access specific hardware, as well as
power and performance constraints.

