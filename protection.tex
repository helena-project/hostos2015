\section{The Next-Generation Embedded OS:\\Protection \emph{is} a New Primitive}
\label{protection}

% pp 33--34, ch 1, sec 4:
In Tanenbaum's \emph{Modern Operating Systems} he asserts, ``The main property
which distinguishes embedded systems from handhelds is the certainty that no
untrusted software will ever run on it''~\cite{tanenbaum}. In this paper we
argue that this is no longer the case. Embedded systems are evolving beyond the
single-application case and now require an operating system that provides
protection to applications in the form of isolation and resource arbitration.
%
This section examines recent advances and trends in embedded hardware and
programming languages that enable novel protection primitives in constrained
systems.

\subsection{Hardware Advances and Trends}

New embedded system platforms will be built on the Cortex-M series of microcontrollers.
While ARM's A-series is substantially more capable and is used in wall-powered
devices such as the Raspberry Pi~\cite{rpi} and BeagleBone Black~\cite{bbb},
its significant power draw (over 1~W in active mode) make it infeasible for
low-power, battery operated devices.
In contrast, Cortex-M series microcontrollers have power draws conducive to
low-power operation while adding hardware features that enable protection.


% Modern ARM devices come in three flavors: the powerful A-series
% microprocessors, the real-time R-series, and the efficient M-series
% microcontrollers.
% \hl{XXX: Why M over A}

{\bf Memory Protection Units.}
As Cortex-M's are a microcontroller design---a System-on-Chip with tightly
integrated memory---they do not (nor will they likely ever) integrate enough
memory to merit a Memory Management Unit (MMU). Instead, the Cortex-M series
includes a Memory Protection Unit (MPU), a lightweight, efficient construct
that provides the memory protection features (e.g. traps illegal memory
accesses such as writing to read-only memory) similar to those doung in an MMU
but without address translatation and at a much finer granularity.
With OS and compiler assistance~\endnote{Relocation requires an application to
be compiled with position independent code} an MPU
can enable isolated applications, shared
libraries, and even possible relocation of running code.
% Pat: I'm 90% sure of how to do relocation with PIC, but I need to think about it more
MPUs are much more fine-grained than typical virtual memory. MPUs are able to
address regions as small a 32~bytes, whereas MMUs typically use at least 4~KB
pages. Moreover, MPUs support regions of any size that is a power of two larger
than 32 bytes (27 sizes in practice)~\cite{cortexm4-ug:ch4.5}, whereas MMUs
support a limited number of page sizes~\endnote{The Itanium architecture
supports eight page sizes, while x86 and ARMv7 both only support three}
MPUs do not, however, perform any translation, so mechanisms such as swap and
dynamic page allocation may not be feasible.

{\bf Multi-Processor Platforms.}
% XXX: This section is a work-in-progress...
Modern embedded platforms increasingly include multiple microcontrollers.
For example, the Nest
Protect~\cite{nestprotect} includes a main Cortex-M4 application controller, a secondary
Cortex-M0+ peripheral processor and an EM357 802.15.4 radio SoC with an
onboard Cortex-M3~\cite{nestprotect-teardown}.
Adding additional microcontrollers can allow offloading timing-critical
communication functionality or running certain computations on a microcontroller
with a different energy profile.
% Often, peripheral devices like radio modules are actually a full blown
% microcontroller that allows the application controller to offload low-level radio
% functionality and reduce overall power~\cite{nrf51822,cc2540}. In other cases,
% a similar microcontroller with a different energy profile is added to provide
% a runtime option for an energy-performance tradeoff.
Multiple
%, hetergeneous
processors provide an opportunity for
the strictest isolation, stochastic and deterministic real-time schedules, and
computation offloading. It is less clear, however, how to abstract
system-specific hardware for general applications and is an open question in
the design of a new operating system.


% ARM TrustZone is also functionally like having a separate core, or at least
% that's the abstraction it tries to provide. Only available on Cortex-A's
% though

% Could also be interesting to talk about crypto co-processors here



%% OLD TEXT: impl-heavy
% \name leverages multiprocessor environments to provide protection where
% language-level and memory isolation are insufficient. In a multi-application
% environment, time-sensitive applications (e.g. that must process requests
% within a single radio scheduling quantum) are protected from interference by,
% e.g compute heavy applications. In addition, \name schedules applications on
% different processors to applications handling sensitive data from side-channel
% attacks by other applications.

%Advances:
%  MPUs
%    -- capabilities
%    -- MPU vs MMU (seed of both?)
%
%Trends:
%  M vs A
%    -- Why deeply embedded (M) still relevant
%    -- Maybe Pebble vs other watches example?
%
%  Multi-Core (really Multi-MCU?)
%    -- solid protection / boundary
%    -- compare with TrustZone?
%    -- App / HW specific; need to expose but can't feature / focus / rely on


\input{protection-pl}

