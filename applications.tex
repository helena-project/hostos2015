\section{Evolved Embedded Applications}
In a first evolutionary cycle of the embedded devices applications were written
as a essential part of a runtime environment on the device. During secondary
cycle operating systems like TinyOS, Contiki, FreeRTOS emerged separating
application and OS spaces. The development became easier  and applications
got complex but the resulting code was still compiled to a monolithic image and
uploaded to the device.

Now the third evolutionary cycle is emerging: multiple and independently
developed application has to co-exist on the same device (like in Pebble watch);
and embedded devices are becoming modular. The later is evident with
multi-billion companies like Samsung, Telefonica and GE innovating with SimBand
\footnote{http://www.samsung.com/us/globalinnovation/innovation_areas/}, Wzzard
\footnote{http://bb-smartsensing.com/wzzard-sensing-platform/}, ThinkingThings
\footnote{http://www.thinkingthings.telefonica.com/}, Spotter UNIQ
\footnote{https://www.quirky.com/shop/982-spotter-uniq-customizable-multipurpose-sensor#}
. The trend is to create a core hardware platform where adding sensory
peripherals is done by consumer in a Lego-like fashion.

There trends completely change the way applications for the embedded devices
have been developed last five decades. Developer have very little control on the
application execution model, its coexistence with other application and what
peripherals are connected to the embedded device. Instead application developer
expect that underlying operating system will perform fair resource allocation,
protect the application from malicious or malfunctioning applications and
peripherals. 

% about execution mode

% about abstraction

% connect to rest paper from expectations

