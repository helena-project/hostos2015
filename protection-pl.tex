\subsection{Language Level Protection}

The C programming language has long been the language of choice for system-level
programming, including operating systems development. C is inherently an unsafe
programming language \cite{kint:osdi2012, undefined:apsys2012}. As such, much
effort has been made to develop operating systems in high-level languages with
stricter semantics \cite{singularity:sigops, house:icfp2005, unikernels:2013}.
Type safety, memory safety, and strict aliasing each provide support for
operating system protection at the language level.

\paragraph{Strong Type Safety.}
Strong, strict types allow for abstractions of low-level hardware mechanisms
that cannot be subverted by safe code. Because the type system cannot be
subverted, hardware mechanisms correctly modeled as type values exposing typed interfaces
guarantee that users of the interface are utilizing the underlying hardware in a
safe manner.
% Of course, the underlying interface implementation continues to be
% responsible for implementing the desired logic correctly.
Taking advantage of strict typing requires minimizing the amount of unsafe code,
i.e. code that interfaces with hardware directly.
Although challenging, we argue that careful interface design will allow
for minimum unsafe code in the operating system and the maximum cost-free
protection from a strong type system.
% As such, it is
% important to design interfaces that minimize the ability for logic errors to be
% introduced via their implementation. We argue that through careful interface
% design, unsafe code, or code that interfaces with the hardware directly, can be
% minimized, reducing the amount of code that must be audited to ensure
% correctness. Identifying the minimum amount of unsafe code to expose a safe
% interface is a core challenge, but successfully doing so results in strong,
% cost-free protection.

\paragraph{Memory Safety.}
Issues with memory safety---dangling pointers, use-after-free and
double-free errors, access to unallocated memory, and pointer arithmetic
errors---have long plagued operating systems written in
languages with weak memory semantics.
% Dangling pointers, use-after-free and
% double-free errors, access to unallocated memory, and pointer arithmetic errors
% are a few of the issues kernel developers encounter when writing in such a
% language.
A language that guarantees memory safety ensures that some or all of
these types of errors cannot occur once a program has compiled.
For instance, a kernel with drivers written in a memory safe language are
memory isolated without the need for hardware support as the
application can only access memory that has been allocated to it.
% A memory safe application can only access memory that has been allocated to it.
% This means that a kernel with drivers written in a memory safe language are
% memory isolated without the need for hardware support: It is impossible for a
% memory-safe driver to sully the integrity of a kernel written in the same
% language.

% A high-level language usually guarantees memory safety through automatic garbage
% collection and bounds checking; the language allocates and frees all memory for
% the user and checks all pointer arithmetic. Because the garbage collector tracks
% active references, automatic garbage collection imposes a runtime performance
% penalty that is difficult to determine deterministically. In a constrained
% system, where applications may require tight bounds on their execution,
% deterministic performance is critical. As such, automatic garbage collection is
% unlikely to be a good fit for embedded systems.

The kernel, however, must still be able to access memory directly
to configure hardware resources.
% Of course, to program hardware, the kernel must be able to access memory
% directly.
As with type safe interfaces, unsafe accesses must be audited to ensure
the overall interface is memory safe, enabling both safe drivers and
% the ideal is to provide a memory safe
% interface to carefully audited memory unsafe operations. This guarantees the
% memory safety of software utilizing the memory safe interfaces, such as drivers,
% while enabling
the kernel's low-level implementation.

\paragraph{Strict Aliasing.}
Strict aliasing rules, such as unique references and read/write references,
%are used to
enforce thread safety
%in modern programming languages
by the language. We seek to
exploit these semantics
% to provide thread-safe hardware access
by modeling
hardware resources as references, allowing two or more applications to run
concurrently without
%fear of race conditions when accessing hardware
hardware race conditions.
% This means that two or more concurrently running applications may
% attempt to access the same hardware, resulting in access patterns unanticipated
% by the hardware. We seek to exploit strict aliasing semantics, such as unique
% and read/write references, by modeling hardware resources as references,
% guaranteeing thread-safe hardware access.
\textit{Unique references}
to hardware
guarantee that only a single active execution context
can access the reference,
%By modeling hardware as a unique reference, a
guaranteeing thread safety to applications holding the reference.
\textit{Read/write references} guarantee that two active contexts can read, but cannot mutate,
the same state.
% If two or more applications require read access to the same
% resource, read/write references can be used to make the same guarantee.
If multiple applications require write access to the same resource, a broker with a
unique reference to the resource can mediate access.
%to said resource.

By composing type safety, memory safety, and strict aliasing, a next-generation
operating system can expose safe interfaces to applications and device drivers
with strong protection guarantees at little performance cost.
