\section{Introduction}

As networking became an integral part of computing through the Internet and
world wide web, system security grew in importance from a niche interest
of the military into a core requirement for every operating system and 
software application. Twenty years ago, we had to be careful about what
floppy disks we inserted into our computers. Today, we have firewalls,
NATs, automatic virus scanners, no-execute bits, virtual machines, 
increasing use of secure HTTP, and and a growing infrastructure for 
authenticating downloaded data and code.

Today, we see the emergence of ``intelligent'' things that integrate computing
with physical devices. Smart watches such as the Pebble provide a clock
application and a limited set of applets, smart light bulbs such as the
Phillips Hue support single functions---on and off, brighter and dimmer---,
while smarter light bulbs such as the PLAYBULB pulse with the music they play
from their integrated speaker.  As embedded systems grow from niche systems
into a more general purpose computing infrastructure, there will be a need to
dynamically load applications and share the infrastructure across multiple
applications.  For example, the Pebble watch supports loading executable code
that can use the builtin sensors and display as well as communicate with
apps on a connected mobile phone.

Historically,
embedded systems have been single-purpose, single-application devices.
As a result, embedded ``operating systems'' have no security mechanisms.
Microcontroller families such as the MSP430 and Atmega do not provide
any hardware mechanisms to support security. With only a few kilobytes of RAM,
they lack virtual memory, memory protection, and lack caches. 
An application developer compiles a monolithic program image that runs 
a single application which has unfettered access to underlying hardware. 

But in the past few years, a new generation of embedded processors
has emerged. These processors, based on the ARM Cortex M architecture,
sit in a middle ground between full-fledged CPUs and microcontrollers.
They are 32 bits, and have tens to hundreds of kilobytes of RAM. They have
memory protection, but no virtual memory. They provide many peripherals
and bus interconnects (SPI, I2C, one-wire, UART/USART, etc.) and
have sub-\uA sleep currents. The Nordic Semiconductor nRF51822, for example,
is an integrated system-on-a-chip (SoC) with a Bluetooth Low Energy 
transceiver and a Cortex M0 processor costs a little more than \$1.

%%it is not true for Contiki. You can compile your application, send the code
% which will be open by os. Hence it is NOT linked into OS at compile time
The key abstraction lacking in traditional embedded operating systems, but
essential to enable the next generation of embedded devices is protection. In
operating systems like TinyOS applications are linked into the
binary image at compile time and all parts of the code have access to the
same address- and name-space. FreeRTOS has a notion of \emph{tasks} which run
independently of the operating system, but this separation is not enforced;
applications have complete access to operating system memory regions and
hardware resources. Contiki's programing model is based on protothread
that are invoked by core in response to an event. Protothreads are cooperatively
schedules and must explicitly yield control back to the kernel. Contiki was
designed more then a decade ago, hence it is designed to not support memory
protection.


We introduce \name, a next-generation operating system for embedded systems.
Modern microcontrollers are both feature rich, with 32-bit processors and
diverse peripherals, and feature poor, with limited memory, energy-hungry
storage and communication, and restricted hardware support (MPUs instead of
MMUs, if at all).
%
It is time for the embedded operating system to evolve from single-application-centric
design---a glorified hardware abstraction layer---% glorified is too colloquial
% "a set of advanced libraries"? sells them too short... fixme
to a real operating system, % don't like "real" either; general-purpose, proper?
one that enables and encourages multiple concurrent, isolated applications,
provides both hardware abstractions and low-level hardware access, and offers
critical services for the applications of the Internet of Things.
%Today's fitness tracker can easily double as a medication reminder, if only
%there was a means to install and run another application.

% Hue: STM32F + CC2530 (zigbee radio)
% Pebble: Also an ST M3
% Jawbone: MSP430F5528
% Fitbit: STM 32L151C6 (another M3) + nRF8001

% THOUGHT:
%
% We make an indirect argument here by designing and OS for ARM Cortex-M.
% Namely that we are leaving other archiectures (pic, msp, avr) behind. There
% is precedent for this, x86 won as a general purpose archiecture, a key step
% towards moving forward in the embedded space is picking an archiecturural
% winner, committing to it, and moving forward. We are doing this implicitly,
% perhaps we should consider adding some text and making it an explicit choice
% somewhere.

% L: I don't think that commitement to ARM benefits the clarity or the research
% contribution of the paper. Rather describing desireble MCU functions for
% the future of embeded devices makes stronger argument.

While protection is not a new primitive in operating system design, it is a
new primitive for embedded operating system design. In the design of \name, we
take advantage of three protection mechanisms recently available to embedded
systems builders:

\begin{enumerate}
  \item \emph{Language level protection} including type safety, memory safety
    and thread safety support in modern systems programming languages.
  \item \emph{Software-managed memory protection} available in the newest
    low-power embedded microcontrollers allow the operating system to enforce
    privilege separation in hardware without the cost or complexity of a virtual
    memory.
  \item \emph{Physically timing protection}. Many new embedded products
    integrate multiple microcontrollers~\endnote{Nest protect has no less than
    three Cortex-M microcontrollers. An M4 for the application controller, an
  M0+ used as a peripheral coprocessor and 802.15.4 SoC with an onboard M3}.
  Operating systems should take advantage of this to guard time-sensitive
  components from others that might compromise timing guarantees (e.g.
  computation heavy tasks).
\end{enumerate}

